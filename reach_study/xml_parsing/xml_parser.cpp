#include "xml_parser.hpp"

#include <stdio.h>
#include <stdlib.h>

#include <iostream>
#include <fstream>

#include <vector>
#include <string>

/*
 * @Author NatalieCloud
 * 
 * @Description
 * This program takes the results generated by the reach study (done in the xml format) and parses those results into a list of data structs.
 * This parsing is done by leveraging rapidxml! 
*/

namespace reachXML {

void xmlParser::parseXML(std::string fname) {

    rapidxml::xml_document<> doc;
    rapidxml::xml_node<> * root_node;
    //Read the file into a vector
    std::ifstream theFile (fname);
    std::vector<char> buffer((std::istreambuf_iterator<char>(theFile)), std::istreambuf_iterator<char>());
	buffer.push_back('\0');
	// Parse the buffer using the xml file parsing library into doc 
	doc.parse<0>(&buffer[0]);
    //Find the root of the data, in our case, boost_serialization
    root_node = doc.first_node(0);
    int count = xmlParser::getItemCount(root_node);
    rapidxml::xml_node<> * item_node = xmlParser::descendToItem(root_node);

    //*poses = (poseData *)malloc(sizeof(poseData) * count);

    // TEST PRINT START

    // rapidxml::xml_node<> * item_node = xmlParser::descendToItem(root_node);
    // struct poseData test;
    // xmlParser::populateStruct(item_node, &test);
    // std::cout.precision(17);
    // std::cout  << test.reachScore << std::endl;
    // TEST PRINT END

    struct poseData poses[count];
    
    xmlParser::populatePoses(item_node, poses, count);


    std::cout << "Number of nodes: " << count << std::endl;
    std::cout << "First node reached? " << poses[0].reachResult << std::endl;
    std::cout << "Reach Score? " << poses[0].reachScore << std::endl;

    //free(poses);
}

int xmlParser::getItemCount(rapidxml::xml_node<> * root_node) {

    root_node = root_node->first_node(0); // <db>
    root_node = root_node->first_node(0); // <results>
    root_node = root_node->first_node(0); // <count>
    root_node = root_node->next_sibling(); // <item_version>
    root_node = root_node->next_sibling(); // <item>
    root_node = root_node->first_node(0); // <count>
    return std::stoi(root_node->value());
}

rapidxml::xml_node<> * xmlParser::descendToItem(rapidxml::xml_node<> * root_node){

    root_node = root_node->first_node(0); // <db>
    root_node = root_node->first_node(0); // <results>
    root_node = root_node->first_node(0); // <count>
    root_node = root_node->next_sibling(); // <item_version>
    root_node = root_node->next_sibling(); // <item>
    root_node = root_node->first_node(0); // <count>
    root_node = root_node->next_sibling(); // <item_version>
    root_node = root_node->next_sibling(); // <item>

    return root_node;
}

void xmlParser::populatePoses(rapidxml::xml_node<> * root_node, struct poseData poses[], int count) {

    if(!poses) {
        return;
    }

    for (int i = 0; i < count && root_node; i++) {
        //struct poseData newPose;
        xmlParser::populateStruct(root_node, &poses[i]);
        //poses[i] = newPose;
        root_node = root_node->next_sibling();
    }
}

void xmlParser::populateStruct(rapidxml::xml_node<> * root_node, struct poseData *data) {

    data->pose = xmlParser::getPoseMatrix(root_node);
    data->reachResult = std::stoi(root_node->first_node(0)->value());
    data->reachScore = std::atof(root_node->first_node(0)->next_sibling()->next_sibling()->value());
}

_Float64 * xmlParser::getPoseMatrix(rapidxml::xml_node<> * item_node) {

    item_node = item_node->first_node(0); // <reached>
    item_node = item_node->next_sibling(); // <goal>
    item_node = item_node->first_node(0); // <matrix>
    item_node = item_node->first_node(0); // <count>
    item_node = item_node->next_sibling(); // <item_version>
    item_node = item_node->next_sibling(); // first <item>

    static _Float64 numMatrix[xmlParser::MATRIX_SIZE];

    for (int i = 0; i < xmlParser::MATRIX_SIZE && item_node; i++) {
        numMatrix[i] = atof(item_node->value());
        item_node = item_node->next_sibling(); // Grabs next item
    }
    return numMatrix;  
}

} //namespace reachXML